### 프로퍼티와 초기화

자바의 필드와 코트린의 프로퍼티
- 자바의 필드는 단순한 변수 선언만 가지기 때문에 접근을 위한 메서드를 따로 만들어야 한다.
- 반면에 코틀린의 프로퍼티는 변수 선언과 기본적인 접근 메서드를 모두 가지고 있고, 따로 접근 메서드를 만들지 않아도 내부적으로 생성하게 된다.

#### 지연 초기화가 필요한 이유

변수나 객체의 값은 생성시 초기화 필요
- 클래스에서는 기본적으로 선언하는 프로퍼티 자료형들은 null을 가질 수 없다.
- 하지만, 객체의 정보가 나중에 나타나는 경우 나중에 초기화 할 수 있는 방법 필요하다.
- 지연 초기화를 위해 lateinit 과 lazy 키워드를 사용한다.

lateinit를 사용한 초기화
- 의존성이 있는 초기화나 unit 테스트를 위한 코드를 작성 시
  - Ex. Car Class 의 초기화 부분에 Engine 클래스와 의존성을 가지는 경우 Engine 객체가 생성되지 않으면 완전하게 초기화 할 수 없는 경우
  - Ex. 단위(Unit) 테스트를 위해 임시적으로 객체를 생성 시켜야 하는 경우
- 제한
  - var 로 선언된 프로퍼티만 가능
  - 프로퍼티에 Setter, Getter 를 사용할 수 없다.
  
프로퍼트 지연 초기화
- 클래스를 선언할 때 프로퍼티 선언은 null을 허용하지 않는다.
- 하지만, 지연 초기화를 위한 lateinit 키워드를 사용하면 프로퍼티에 값이 바로 할당되지 않아도 된다.

lazy를 사용한 지연 초기화 특징
- 호출 시점에 by lazy {...} 정의에 의해 블록 부분의 초기화를 진행한다.
- 불변의 변수 선언인 val에서만 사용 가능하다. (읽기 전용)
- val이므로 값을 다시 변경할 수 없다.

by lazy의 모드(mode)
- 3가지 모드 지정 가능
  - SYNCHRONIZED : 락을 사용해 단일 스레드만이 사용하는 것을 보장(기본값)
  - PUBLICATION : 여러 군데서 호출될 수 있으나 처음 초기화된 후 반환 값을 사용
  - NONE : 락을 사용하지 않기 때문에 빠르지만 다중 스레드가 접근할 수 있다. (값의 일관성을 보장할 수 없음)
  
by를 이용한 위임
- 위임(delegation)
  - 하나의 클래스가 다른 클래스에 위임하도록 선언
  - 위임된 클래스가 가지는 멤버를 참조없이 호출
- 위임을 사용하는 이유
  - 코틀린의 기본 라이브러리는 open 되지 않은 최종 클래스
    - 표준 라이브러리의 무분별한 상속의 복잡한 문제들을 방지
    - 단, 상속이나 직접 클래스의 기능 확장이 어렵다.
  - 위임을 사용하면 위임을 통해 상속과 비슷하게 최종 클래스의 모든 기능을 사용하면서 동시에 기능을 추가 확장 구현할 수 있다.
  
observable 과 vetoable 의 위임
- observable : 프로퍼티를 감시하고 있다가 특정 코드의 로직에서 변경이 일어날 때 호출
- vetoable : 감시보다는 수여한다는 의미로 반환값에 따라 프로퍼티 변경을 허용하거나 취소

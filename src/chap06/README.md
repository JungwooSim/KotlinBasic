### 프로퍼티와 초기화

자바의 필드와 코트린의 프로퍼티
- 자바의 필드는 단순한 변수 선언만 가지기 때문에 접근을 위한 메서드를 따로 만들어야 한다.
- 반면에 코틀린의 프로퍼티는 변수 선언과 기본적인 접근 메서드를 모두 가지고 있고, 따로 접근 메서드를 만들지 않아도 내부적으로 생성하게 된다.

#### 지연 초기화가 필요한 이유

변수나 객체의 값은 생성시 초기화 필요
- 클래스에서는 기본적으로 선언하는 프로퍼티 자료형들은 null을 가질 수 없다.
- 하지만, 객체의 정보가 나중에 나타나는 경우 나중에 초기화 할 수 있는 방법 필요하다.
- 지연 초기화를 위해 lateinit 과 lazy 키워드를 사용한다.

lateinit를 사용한 초기화
- 의존성이 있는 초기화나 unit 테스트를 위한 코드를 작성 시
  - Ex. Car Class 의 초기화 부분에 Engine 클래스와 의존성을 가지는 경우 Engine 객체가 생성되지 않으면 완전하게 초기화 할 수 없는 경우
  - Ex. 단위(Unit) 테스트를 위해 임시적으로 객체를 생성 시켜야 하는 경우
- 제한
  - var 로 선언된 프로퍼티만 가능
  - 프로퍼티에 Setter, Getter 를 사용할 수 없다.
  
프로퍼트 지연 초기화
- 클래스를 선언할 때 프로퍼티 선언은 null을 허용하지 않는다.
- 하지만, 지연 초기화를 위한 lateinit 키워드를 사용하면 프로퍼티에 값이 바로 할당되지 않아도 된다.

lazy를 사용한 지연 초기화 특징
- 호출 시점에 by lazy {...} 정의에 의해 블록 부분의 초기화를 진행한다.
- 불변의 변수 선언인 val에서만 사용 가능하다. (읽기 전용)
- val이므로 값을 다시 변경할 수 없다.

by lazy의 모드(mode)
- 3가지 모드 지정 가능
  - SYNCHRONIZED : 락을 사용해 단일 스레드만이 사용하는 것을 보장(기본값)
  - PUBLICATION : 여러 군데서 호출될 수 있으나 처음 초기화된 후 반환 값을 사용
  - NONE : 락을 사용하지 않기 때문에 빠르지만 다중 스레드가 접근할 수 있다. (값의 일관성을 보장할 수 없음)
  
by를 이용한 위임
- 위임(delegation)
  - 하나의 클래스가 다른 클래스에 위임하도록 선언
  - 위임된 클래스가 가지는 멤버를 참조없이 호출
- 위임을 사용하는 이유
  - 코틀린의 기본 라이브러리는 open 되지 않은 최종 클래스
    - 표준 라이브러리의 무분별한 상속의 복잡한 문제들을 방지
    - 단, 상속이나 직접 클래스의 기능 확장이 어렵다.
  - 위임을 사용하면 위임을 통해 상속과 비슷하게 최종 클래스의 모든 기능을 사용하면서 동시에 기능을 추가 확장 구현할 수 있다.
  
observable 과 vetoable 의 위임
- observable : 프로퍼티를 감시하고 있다가 특정 코드의 로직에서 변경이 일어날 때 호출
- vetoable : 감시보다는 수여한다는 의미로 반환값에 따라 프로퍼티 변경을 허용하거나 취

#### static 변수와 companion 객체

사용범위에 따른 분류
- local, global

보통 클래스는 동적으로 객체를 생성하는데 정적으로 고정하는 방법
- 동적인 초기화 없이 사용할 수 있는 개념으로 자바에서는 static 변수 또는 객체
- 코틀린에서는 이것을 companion object 로 사용
- 프로그램 실행 시 고정적으로 가지는 메모리로 객체 생성 없이 사용. 단, 자주 사용되지 않는 변수나 객체를 만들면 메모리 낭비

#### 최상위 함수 정리

최상위 함수(top-level function)
- 클래스 없이 만들었던 최상위 함수들은 객체 생성 없이도 어디에서든 실행
- package-level function 이라고도 한다.
- 최상위 함수는 결국 자바에서 static final 로 선언된 함수이다.

자바에서 코틀린의 최상위 함수 접근
- 코틀린의 최상위 함수는 클래스가 없으나 자바와 연동시 내부적으로 파일명에 Kt 접미사가 붙은 클래스를 자동 생성하게 된다.
- 자동 변환되는 클래스명을 명시적으로 지정하고자 하는 경우 @file:JvmName("ClassName") 을 코드 상단에 명시한다.

#### object 와 singleton

상속할 수 없는 클래스에서 내용이 변경된 객체를 생성할 때
- 자바의 경우 익명 내부 클래스를 사용해 새로운 클래스 선언
- 코틀린에서는 object 표현식이나 object 선언으로 이 경우를 좀 더 쉽게 처리

object 표현식
- object 선언과 달리 이름이 없으며 싱글턴이 아니다.
- 따라서 object 표현식이 사용될 때마다 새로운 인스턴스가 생성된다.
- 이름이 없는 익명 내부 클래스로 불리는 형태를 object 표현식으로 만들 수 있다.
